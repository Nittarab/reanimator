/**
 * GitHub API interactions for branch creation, commits, and PR creation
 */

import * as core from '@actions/core';
import * as github from '@actions/github';
import * as exec from '@actions/exec';

/**
 * Create a new branch with incident ID in the name
 * @param incidentId - The incident identifier
 * @returns The branch name
 */
export async function createBranch(incidentId: string): Promise<string> {
  const branchName = `fix/incident-${incidentId}`;
  core.info(`Creating branch: ${branchName}`);
  
  try {
    // Create and checkout new branch
    await exec.exec('git', ['checkout', '-b', branchName]);
    core.info(`Branch ${branchName} created successfully`);
    return branchName;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create branch: ${errorMessage}`);
  }
}

/**
 * Commit changes with a descriptive message
 * @param incidentId - The incident identifier
 * @param serviceName - The affected service name
 * @param errorMessage - Brief error description
 */
export async function commitChanges(
  incidentId: string,
  serviceName: string,
  errorMessage: string
): Promise<void> {
  core.info('Committing changes');
  
  try {
    // Configure git user
    await exec.exec('git', ['config', 'user.name', 'AI SRE Bot']);
    await exec.exec('git', ['config', 'user.email', 'ai-sre-bot@github.com']);
    
    // Add all changes
    await exec.exec('git', ['add', '.']);
    
    // Create commit message
    const commitMessage = `fix: automated remediation for incident ${incidentId}

Service: ${serviceName}
Error: ${errorMessage}

This fix was automatically generated by the AI SRE Platform.`;
    
    await exec.exec('git', ['commit', '-m', commitMessage]);
    core.info('Changes committed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to commit changes: ${errorMessage}`);
  }
}

/**
 * Push branch to remote repository
 * @param branchName - The branch to push
 */
export async function pushBranch(branchName: string): Promise<void> {
  core.info(`Pushing branch: ${branchName}`);
  
  try {
    await exec.exec('git', ['push', '-u', 'origin', branchName]);
    core.info('Branch pushed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to push branch: ${errorMessage}`);
  }
}

/**
 * Create a pull request with post-mortem
 * @param branchName - The branch with fixes
 * @param incidentId - The incident identifier
 * @param serviceName - The affected service
 * @param postMortem - The post-mortem document
 * @param baseBranch - The base branch to merge into (default: main)
 * @returns The PR URL
 */
export async function createPullRequest(
  branchName: string,
  incidentId: string,
  serviceName: string,
  postMortem: string,
  baseBranch: string = 'main'
): Promise<string> {
  core.info('Creating pull request');
  
  try {
    const token = process.env.GITHUB_TOKEN;
    if (!token) {
      throw new Error('GITHUB_TOKEN not found in environment');
    }
    
    const octokit = github.getOctokit(token);
    const context = github.context;
    
    const title = `fix: automated remediation for incident ${incidentId} (${serviceName})`;
    const body = `## Automated Remediation

This pull request was automatically generated by the AI SRE Platform to address incident \`${incidentId}\`.

${postMortem}

---
**Service**: ${serviceName}
**Incident ID**: ${incidentId}
**Generated by**: AI SRE Platform`;
    
    const { data: pr } = await octokit.rest.pulls.create({
      owner: context.repo.owner,
      repo: context.repo.repo,
      title,
      body,
      head: branchName,
      base: baseBranch,
    });
    
    core.info(`Pull request created: ${pr.html_url}`);
    return pr.html_url;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create pull request: ${errorMessage}`);
  }
}

/**
 * Check if there are any changes to commit
 * @returns True if there are changes, false otherwise
 */
export async function hasChanges(): Promise<boolean> {
  try {
    let output = '';
    await exec.exec('git', ['status', '--porcelain'], {
      listeners: {
        stdout: (data: Buffer) => {
          output += data.toString();
        },
      },
    });
    
    return output.trim().length > 0;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to check git status: ${errorMessage}`);
  }
}
